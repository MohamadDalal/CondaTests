import pickle
import pandas
from ClassCluster import *
from time import perf_counter
import seaborn as sns
import matplotlib as plt
import sklearn.cluster as clst

# This function is used to create pandas dataframes of the lists of lists generated by the RNG objects
# Cols is the column names list that is found in RNG1 and RNG2 for example
def makeDF(List, Cols=None):
    DF = []
    try:
        DF = pandas.DataFrame(List,columns=Cols)
    except Exception as e:
        print(e)
        New = np.transpose(List)
        DF = pandas.DataFrame(New, columns=Cols)
    finally:
        #print(DF)
        return DF

def multiRound(Object:ClusterSampler,Iterations:int, SampleSize:int, PopSize:int):
    for i in range(Iterations):
        Object.run(SampleSize, PopSize)

#Run to create populations and take samples from it
def test():
    StartTime = perf_counter()
    Pop = ClusterPopulations(1000000)
    PopTime = perf_counter()
    print(f'Population created in {PopTime-StartTime}\n'
          f'Time since start {PopTime-StartTime}')
    Sampler = ClusterSampler(Pop)
    multiRound(Sampler, 100, 100, 10000)
    #Sampler.QuickRun(100, 10000)
    SampleTime = perf_counter()
    print(f'Sample done in {SampleTime - PopTime}\n'
          f'Time since start {SampleTime - StartTime}')
    Ting = (_,_,_,_,_,_) = Sampler.ClusterAll()
    ClusterTime = perf_counter()
    print(f'Clustering done in {ClusterTime - SampleTime}\n'
          f'Time since start {ClusterTime - StartTime}')
    return [Pop, Sampler, Ting]


# This function is used to run multiple rounds at once instead of having to do that manually
# Iterations is number of rounds to run, and size is the samples created per round
#def multiRound(Object:RNG,Iterations:int, Size:int):
#    for i in range(Iterations):
#        Object.run(Size)

# Function used to plot line plots for each list of correlations alone
def plotAllLine(DF, Columns):
    plt.rc("font", size=16)
    AxesList = []
    for i in range(len(Columns)):
        ax = sns.lineplot(data=DF, x=DF.index, y=Columns[i])
        Center = DF.iloc[-5, i]
        ax.axhspan(Center-0.0005, Center+0.0005, 0.85, ec="black", fc="gray", alpha=0.7)

        #print(f'Adding line at {DF.iloc[-5, i] - 0.0005}')
        #ax.axhline(DF.iloc[-5, i] - 0.0005, 0.5, 1)
        #ax.axhline(DF.iloc[-5, i] + 0.0005, 0.5, 1)
        AxesList.append(ax)
        plt.pyplot.show()
    return AxesList

# Function used to plot scatter plots for all combinations of random variables
def plotAllScatter(DF,Columns):
    plt.rc("font", size=12)
    AxesList = []
    for i in range(len(Columns)):
        for j in range(i+1,len(Columns)):
            ax = sns.scatterplot(data=DF, x=Columns[i], y=Columns[j])
            #ax = sns.regplot(data=DF, x=Columns[i], y=Columns[j], ci=None)
            #ax.text(0.85, 1.05, "Something", transform=ax.transAxes)
            AxesList.append(ax)
            plt.pyplot.show()
    return AxesList

def plotAllReg(DataDF,Columns, CorrDF):
    plt.rc("font", size=12)
    AxesList = []
    for i in range(len(Columns)):
        for j in range(i + 1, len(Columns)):
            ax = sns.regplot(data=DataDF, x=Columns[i], y=Columns[j], ci=None, line_kws={"color":"k"})
            Correlation = CorrDF[Columns[i]+Columns[j]].iloc[-1]
            ax.text(0.70, 1.03, f"Correlation: {Correlation:.3f}", transform=ax.transAxes)
            AxesList.append(ax)
            plt.pyplot.show()
    return AxesList

# Does what plotAllLine does, but it combines all the plots in one figure
def subplotAllLine(DF, Columns):
    plt.rc("font", size=5)
    Num = len(Columns)
    Cols = int(np.ceil(np.math.sqrt(Num)))
    Rows = int(np.ceil(Num/Cols))
    print(f'Num={Num}\tRows={Rows}\tCols={Cols}')
    Fig, ax = plt.pyplot.subplots(Rows,Cols)
    Index = 0
    for i in range(Num):
        print(f'Current Row={Index//Cols}\tCurrent Collumn={Index%Cols}')
        sns.lineplot(data=DF, x=DF.index, y=Columns[i], ax=ax[Index//Cols][Index%Cols])
        Index += 1
    Fig.tight_layout()
    Fig.show()
    return Fig, ax

# Does what plotAllScatter does, but it combines all the plots in one figure
def subplotAllScatter(DF, Columns):
    plt.rc("font", size=5)
    L   = len(Columns)
    Num = (L*(L-1)/2)
    Cols = int(np.ceil(np.math.sqrt(Num)))
    Rows = int(np.ceil(Num/Cols))
    print(f'Num={Num}\tRows={Rows}\tCols={Cols}')
    Fig, ax = plt.pyplot.subplots(Rows,Cols)
    Index = 0
    for i in range(len(Columns)):
        for j in range(i+1,len(Columns)):
            print(f'Current Row={Index//Cols}\tCurrent Collumn={Index%Cols}')
            sns.scatterplot(data=DF, x=Columns[i], y=Columns[j], ax=ax[Index//Cols][Index%Cols])
            Index += 1
    Fig.tight_layout()
    Fig.show()
    return Fig, ax

# Plots a scatter plot of means and standard deviations that are clustered using KMeans
def PlotKMean(Obj:ClusterSampler, SavePath:str, Clusters = 8, Round = -1,
              Parents = True,Legend="auto", Save = False):
    Dict = Obj.GetRoundData(Round, Parents)
    KList = np.transpose([Dict["Means"], Dict["StdDivs"]])
    K = clst.KMeans(n_clusters=Clusters)
    K.fit_predict(KList)
    DF = pandas.DataFrame(data={"Means":Dict["Means"], "StdDivs":Dict["StdDivs"], "Labels":K.labels_})
    print(DF)
    ax = sns.scatterplot(data=DF, x="Means", y="StdDivs",
                                         hue="Labels", palette="Paired", legend=Legend)
    if (Save) and (len(SavePath) > 0):
        plt.pyplot.savefig(SavePath)
    plt.pyplot.show()
    return ax,DF

# Plots scatter diagram of Means and Standard deviations
def PlotScatter(Obj:ClusterSampler, SavePath:str, Round = -1, Parents = True, Save = False):
    Dict = Obj.GetRoundData(Round, Parents)
    DF = pandas.DataFrame(data=Dict)
    print(DF)
    DF = DF.drop(["V", "W", "X", "Y", "Z"], axis=1)
    print(DF)
    ax = sns.scatterplot(data=DF, x="Means", y="StdDivs")
    if (Save) and (len(SavePath) > 0):
        plt.pyplot.savefig(SavePath)
    plt.pyplot.show()
    return ax
# Plots a swarmplot of the correlations of all variables with the parent variables V,W,X,Y,Z
# The opaque points correspond to which cluster each point belongs to
# If a variable belongs to Vs cluster then the green point will be opaque
def PlotSwarm(Obj:ClusterSampler, SavePath:str, Round = -1, Parents = False):
    Dict = Obj.GetRoundData(Round, Parents)
    DF = pandas.DataFrame(data=Dict)
    DF = DF.drop(["Means", "StdDivs"], axis=1)
    if Parents:
        IndexList = ["V","W","X","Y","Z"]
        for i in range(3**5):
            IndexList.append(f'{i+1}')
    else:
        IndexList = [i+1 for i in range(3**5)]
    DF.insert(0, "index",IndexList)
    DF = DF.melt("index", var_name="CorrWith")
    _,_,_,_,_,Labels = Obj.ClusterAll()
    if not Parents:
        for i in range(5):
            Labels.pop(0)
    List = [False for i in range(len(DF))]
    for i in range(len(Labels)):
        j = Labels[i]
        if j != 5:
            List[(3 ** 5) * j + i] = True
    DF = pandas.concat([DF, pandas.DataFrame(List, columns=["Cluster"])], axis=1)
    sns.scatterplot(data=DF[DF["Cluster"] == True], x="index", y="value",
                    hue="CorrWith",palette=["g", "y", "r", "m", "b"], alpha=1)
    ax = sns.scatterplot(data=DF[DF["Cluster"] == False], x="index", y="value",
                         hue="CorrWith", palette=["g", "y", "r", "m", "b"], alpha=0.2, legend=False)
    #ax.legend(loc='center left', bbox_to_anchor=(1.25, 0.5), ncol=1)
    plt.pyplot.savefig(SavePath)
    plt.pyplot.show()
    return DF, ax

# Write pickle object
def PickleWrite(Obj, Path):
    with open(Path, "wb") as file:
        pickle.dump(Obj, file)

# Read pickled object
def PickleRead(Path):
    with open(Path, "rb") as file:
        result = pickle.load(file)
    return result
