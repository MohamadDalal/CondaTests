import pickle
import pandas
from ClassCluster2 import *
from time import perf_counter
import seaborn as sns
import matplotlib as plt

# This function is used to create pandas dataframes of the lists of lists generated by the RNG objects
# Cols is the column names list that is found in RNG1 and RNG2 for example
def makeDF(List, Cols=None):
    DF = []
    try:
        DF = pandas.DataFrame(List,columns=Cols)
    except Exception as e:
        print(f'\tHandled Error:{e}')
        New = np.transpose(List)
        DF = pandas.DataFrame(New, columns=Cols)
    finally:
        #print(DF)
        return DF

def multiRound(Object:ClusterSampler,Iterations:int, SampleSize:int, PopSize:int):
    for i in range(Iterations):
        Object.run(SampleSize, PopSize)

#Run to create populations and take samples from it
def test():
    StartTime = perf_counter()
    Pop = ClusterPopulations(1000000)
    PopTime = perf_counter()
    print(f'Population created in {PopTime-StartTime}\n'
          f'Time since start {PopTime-StartTime}')
    Sampler = ClusterSampler(Pop)
    multiRound(Sampler, 100, 100, 10000)
    SampleTime = perf_counter()
    print(f'Sample done in {SampleTime - PopTime}\n'
          f'Time since start {SampleTime - StartTime}')
    Ting = (_,_,_,_,_,_) = Sampler.ClusterAll()
    ClusterTime = perf_counter()
    print(f'Clustering done in {ClusterTime - SampleTime}\n'
          f'Time since start {ClusterTime - StartTime}')
    return [Pop, Sampler, Ting]

def test2(epsilon = 0.005):
    StartTime = perf_counter()
    Pop = ClusterPopulations(1000000)
    PopTime = perf_counter()
    print(f'Population created in {PopTime - StartTime}\n'
          f'Time since start {PopTime - StartTime}')
    Sampler = ClusterSampler(Pop)
    Sampler.runUntilConverge(epsilon, 100, 1000)
    # Sampler.QuickRun(100, 10000)
    SampleTime = perf_counter()
    print(f'Sample done in {SampleTime - PopTime}\n'
          f'Time since start {SampleTime - StartTime}')
    Ting = (_, _, _, _, _, _) = Sampler.ClusterAll()
    ClusterTime = perf_counter()
    print(f'Clustering done in {ClusterTime - SampleTime}\n'
          f'Time since start {ClusterTime - StartTime}')
    return [Pop, Sampler, Ting]


# Function used to plot line plots for each list of correlations alone
def plotAllLine(DF, Columns, PopObj:ClusterPopulations, SavePath = "", Save = False):
    #plt.rc("font", size=12)
    AxesList = []
    for i in range(1,len(Columns)):
        ax = sns.lineplot(data=DF, x=DF.index, y=Columns[i])
        RealCorr = PopObj.Corr[i]
        Correlation = DF.iloc[-1, i]
        #print(f'Adding line at {DF.iloc[-5, i] - 0.0005}')
        ax.text(0.70, 1.03, f"Approx Corr: {Correlation:.3f}", transform=ax.transAxes)
        ax.text(0, 1.03, f"Real Corr: {RealCorr:.3f}", transform=ax.transAxes)
        ax.axhline(RealCorr, 0, 1, color="r")
        #ax.axhline(DF.iloc[-5, i] + 0.0005, 0.5, 1)
        AxesList.append(ax)
        if Save and (len(SavePath) > 0):
            plt.pyplot.savefig(f'SavePath{i}')
        plt.pyplot.show()
    return AxesList

# Function used to plot scatter plots for all combinations of random variables
def plotAllScatter(DF,Columns, Obj:ClusterSampler = None, SavePath = "", Save = False):
    #plt.rc("font", size=12)
    AxesList = []
    for i in range(1,len(Columns)):
        ax = sns.scatterplot(data=DF, x=Columns[0], y=Columns[i])
        if not type(Obj) == type(None):
            Correlation = Obj.Corrs[i][-1]
            ax.text(0, 1.03, f"Correlation: {Correlation:.3f}", transform=ax.transAxes)
        AxesList.append(ax)
        if Save and (len(SavePath) > 0):
            plt.pyplot.savefig(f'SavePath{i}')
        plt.pyplot.show()
    return AxesList

def plotAllReg(DataDF,Columns, Obj:ClusterSampler = None, SavePath = "", Save = False):
    #plt.rc("font", size=12)
    AxesList = []
    for i in range(1,len(Columns)):
        ax = sns.regplot(data=DataDF, x=Columns[0], y=Columns[i], ci=None, line_kws={"color":"k"})
        if not type(Obj) == type(None):
            Correlation = Obj.Corrs[i][-1]
            ax.text(0, 1.03, f"Correlation: {Correlation:.3f}", transform=ax.transAxes)
        AxesList.append(ax)
        if Save and (len(SavePath) > 0):
            plt.pyplot.savefig(f'SavePath{i}')
        plt.pyplot.show()
    return AxesList


def PlotTopology(Obj:ClusterSampler, SavePath = "", Round = -1, Save = False):
    PointsX = [Obj.ObjPop.Pos[i][0] for i in range(len(Obj.ObjPop.Pos))]
    PointsY = [Obj.ObjPop.Pos[i][1] for i in range(len(Obj.ObjPop.Pos))]
    _,_,_,_,_,Labels = Obj.ClusterAll(Round)
    Dict = {"PosX": PointsX, "PosY": PointsY, "Cluster": Labels}
    DF = pandas.DataFrame(data=Dict)

    ax = sns.scatterplot(data=DF, x="PosX", y="PosY", hue="Cluster", palette={1:"r", 2:"y", 3:"g", 4:"m", 5:"b"})
    if Round<0:
        R = len(Obj.Corrs[0]) + Round
    else:
        R = Round
    ax.text(0, 1.03, f"Round {(R)}", transform=ax.transAxes)
    if Save and (len(SavePath) > 0):
        plt.pyplot.savefig(SavePath)
    plt.pyplot.show()
    return ax, DF

# Write pickle object
def PickleWrite(Obj, Path):
    with open(Path, "wb") as file:
        pickle.dump(Obj, file)

# Read pickled object
def PickleRead(Path):
    with open(Path, "rb") as file:
        result = pickle.load(file)
    return result
